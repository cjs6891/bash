Terminal Printing

https://linux.die.net/man/1/echo

echo, puts a new line after every "echo" invocation by default, printf does not

double quotes "" can't print special characters, i.e. a ! -or- ?

# echo "Hello!"
-bash: !": event not found

# echo 'Hello!'
Hello!

variable substitution doesn't work with single quotes ''


https://linux.die.net/man/1/printf

printf takes "" text delimited by spaces, by default printf doesn't have new line by default like the echo command; it has to be specified with \n.

# printf "Hello World."
Hello World.[root@el7_blog.local]#

# printf "Hello World.\n"
Hello World.
[root@el7_blog.local]#

Colorizing
http://tldp.org/LDP/abs/html/colorizing.html

 - - - - - 

Variables & Environmental Variables

In BASH the type for every variable is string with or without quotes

To view all the environmental variables issued to a terminal issue the # env command. 

# pgrep to obtain pid(s) for running processes

https://linux.die.net/man/1/pgrep

# pgrep httpd
8499
8500
8501

obtain environment variables of PID by using

# cat /proc/PID/environ

# cat /proc/8499/environ
LANG=CPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/binNOTIFY_SOCKET=/run/systemd/notify

use "tr" for substitution, ex. substitute '\0' with '\n'

https://linux.die.net/man/1/tr

# cat /proc/8499/environ | tr '\0' '\n'
LANG=C
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin
NOTIFY_SOCKET=/run/systemd/notify

set variables:
apple_count=5

IF Variable has a space use '' -or- ""
output='Hello World!'

print variables
# echo $apple_count
5

# echo ${apple_count}
5

# echo $output
Hello World!

# echo ${output}
Hello World!

the # export command is used to set the env variable

# env | grep HISTSIZE
HISTSIZE=1000

# export HISTSIZE=2500
# env | grep HISTSIZE
HISTSIZE=2500

add new path to $PATH variable

# PATH="$PATH:/root/System_Administration"
# export PATH
# echo $PATH

finding the length of a string

# length=${#var}
# var=0123456789
echo ${#var}
10

Identifying the current shell
To identify the shell which is currently being used, use the SHELL environment variable.

# echo $SHELL
/bin/bash

#!/bin/bash


Checking for super user (root)

if [ $UID -ne 0 ]; then
  echo "You're NOT root, please run as root."
else
  echo "You're root, be careful..."
fi

Modifying the Bash prompt string
(username@hostname:~$)

The PS1 environment variable defines the primary prompt. The default prompt is defined by a line in the ~/.bashrc file

\u = username
\h = hostname
\W = current working directory

# echo $PS1
[\u@\h \W]\$

Function to prepend to environment variables
Environment variables are often used to store a list of paths of where to search for executables, libraries, and so on. Example, $PATH

add "/root/System_Administration" to $PATH variable

# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin

# export PATH="$PATH:/root/System_Administration"
# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/System_Administration


Math with the shell
The Bash shell performs basic arithmetic operations using the let, (( )), and [] commands. The expr and bc utilities are used to perform advanced operations.

# no1=8
# no2=4
# let result=$no1+no2
# echo $result
12

Other uses of let command are as follows:

increment:
# echo $no1
8

# let no1++
# echo $no1
9

decrement
# echo $no2
4
# let no2--
# echo $no2
3

shorthands
add 6 to no1
# echo $no1
9

# let no1+=6
# echo $no1
15

subtract 2 from no2
# echo $no2
3

# let no2-=2
# echo $no2
1

The [] operator is used in the same way as the let command
# echo $no1 && echo $no2
15
1

# result=$[ no1 + no2 ] && echo $result
16

The (( )) operator can also be used
# result=$(( no1 + 100 )) && echo $result
115

The expr expression can be used for basic operations
# result=`expr 3 + 4`
# echo $result
7

# echo $no1
15

# result=$(expr $no1 + 10)
# echo $result
25

The preceding methods do not support floating point numbers, and operate on integers only.

The bc application, the precision calculator, is an advanced utility for mathematical operations. It has a wide range of options. We can perform floating point arithmetic and use advanced functions.

# echo "4 * 0.56" | bc
2.24

# no=54
# result=`echo "$no * 1.5" | bc`
# echo $result
81.0

scale decimal places
# echo "scale=2;22/7" | bc
3.14
# echo "scale=3;22/7" | bc
3.142
# echo "scale=4;22/7" | bc
3.1428

# echo "sqrt(100)" | bc
10

# echo "10^2" | bc
100

Playing with file descriptors and redirection
File descriptors are integers associated with the input and output streams. The best-known file descriptors are stdin, stdout, and stderr. The contents of one stream can be redirected to another.

Shell scripts frequently use standard input (stdin), standard output (stdout), and standard error (stderr). A script can redirect output to a file with the greater-than symbol. Text generated by a command may be normal output or an error message. By default, both normal output (stdout) and error messages (stderr) are sent to the display. The two streams can be separated by specifying a specific descriptor for each stream.


File descriptors are integers associated with an opened file or data stream. File descriptors 0, 1, and 2 are reserved:

0: stdin
1: stdout
2: stderr

The redirection operators (> and >>) send output to a file instead of the terminal. The > and >> operators behave slightly differently. Both redirect output to a file, but the single greater-than symbol (>) empties the file and then writes to it, whereas the double greater-than symbol (>>) adds the output to the end of the existing file.

By default, the redirection operates on standard output. To explicitly take a specific file descriptor, you must prefix the descriptor number to the operator.

If you are familiar with file access in other programming languages, you may be familiar with the modes for opening files. These three modes are commonly used:
 - Read mode
 - Write with append mode
 - Write with truncate mode

The < operator reads from the file to stdin. The > operator writes to a file with truncation (data is written to the target file after truncating the contents). The >> operator writes to a file by appending (data is appended to the existing file contents and the contents of the target file will not be lost).

Use the greater-than symbol (>) to add text to a file:
# echo "Hello." > tmp.txt

*** If tmp.txt already exists, the single greater-than sign (>) will delete any previous contents

# cat tmp.txt
Hello.

Use double-greater-than (>>) to append text to a file:
# echo 'Good Bye!' >> tmp.txt
# cat tmp.txt
Hello.
Good Bye!

When a command exits because of an error, it returns a nonzero exit status. The command returns zero when it terminates after successful completion. The return status is available in the special variable $? (run echo $? immediately after the command execution statement to print the exit status).

# echo $?

You can redirect stderr to one file and stdout to another file.
# cmd 2>stderr.txt 1>stdout.txt

It is also possible to redirect stderr and stdout to a single file by converting stderr to stdout using this preferred method:
# cmd 2>&1 allOutput.txt

This can be done even using an alternate approach:
$ cmd &> output.txt 

If you don't want to see or save any error messages, you can redirect the stderr output to /dev/null, which removes it completely.

The tee command reads from stdin and redirects the input data to stdout and one or more files.

In the following code, the stdin data is received by the tee command. It writes a copy of stdout to the output.txt file and sends another copy as stdin for the next commandn $ cat -n. The cat -n command puts a line number for each line received from stdin and writes it into stdout:

$ cat a* | tee output.txt | cat -n
cat: a1.txt: Permission denied
     1  alfa2
     2  alfa

$ cat output.txt
alfa2
alfa

*** The tee command reads only from stdin

*** By default, the tee command overwrites the file. Including the -a option will force it to append the new data.

To send two copies of the input to stdout, use - for the filename argument:

$ echo 'Hello World!' | tee -
Hello World!
Hello World!

Alternately, we can use /dev/stdin as the output filename to use stdin.Similarly, use /dev/stderr for standard error and /dev/stdout for standard output. These are special device files that correspond to stdin, stderr, and stdout.

Redirection from a file to a command
We can read data from a file as stdin with the less-than symbol (<):

$ cat < a.txt
alfa


Arrays and associative arrays
Arrays allow a script to store a collection of data as separate entities using indices (indexes). Bash supports both regular arrays that use integers as the array index, and associative arrays, which use a string as the array index. Regular arrays should be used when the data is organized numerically, for example, a set of successive iterations. Associative arrays can be used when the data is organized by a string, for example, host names.

Arrays can be defined using different techniques:

Define an array using a list of values in a single line:
# array_var=(test1 test2 test3 test4)
** Values will be stored in consecutive locations starting from index 0

firstArray=(one two three four five six)

Print the contents of an array at a given index using the following commands:
# echo ${firstArray[0]}
one

Print all of the values in an array as a list, using the following commands:
# echo ${firstArray[*]}
one two three four five six

Alternately, you can use the following command:
# echo ${firstArray[@]}
one two three four five six

Print the length of an array (the number of elements in an array):
# echo ${#firstArray[*]}
6

Alternately, define an array as a set of index-value pairs:
# array_var[0]="test1"
# array_var[1]="test2"
# array_var[2]="test3"
# array_var[3]="test4"
# array_var[4]="test5"
# array_var[5]="test6"

# secondArray[0]=alfa
# secondArray[1]=bravo
# secondArray[3]=charlie
# secondArray[4]=delta

Print the contents of an array at a given index using the following commands:
# echo ${secondArray[0]}
alfa

Print all of the values in an array as a list, using the following commands:
# echo ${secondArray[*]}
alfa bravo charlie delta

Alternately, you can use the following command:
# echo ${secondArray[@]}
alfa bravo charlie delta

Print the length of an array (the number of elements in an array):
# echo ${#secondArray[*]}
4

associative arrays
An associative array can use any text data as an array index. A declaration statement is required to define a variable name as an associative array.

# declare -A fruit_value

# fruit_value=([apple]='$1.00' [orange]='$0.50')

# echo "Price Per Apple: ${fruit_value[apple]}"
Price Per Apple: $1.00


Listing of associative indexes (also works with standard arrays)
# echo ${!fruit_value[*]}
orange apple

Alternatively
# echo ${!fruit_value[@]}
orange apple

Visiting aliases
